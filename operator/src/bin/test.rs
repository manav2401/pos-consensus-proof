use pos_consensus_proof_operator::contract::ContractClient;
use sp1_sdk::{ProverClient, SP1ProofWithPublicValues};

use alloy_sol_types::{sol, SolCall};

sol! {
    contract ConsensusProofVerifier {
        function verifyConsensusProof(
            bytes calldata proof,
            bytes calldata publicValues
        ) public;
    }
}

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const CONSENSUS_PROOF_ELF: &[u8] =
    include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    dotenv::dotenv().ok();

    println!("Hello, world!");

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (_pk, vk) = client.setup(CONSENSUS_PROOF_ELF);

    let proof = SP1ProofWithPublicValues::load("proof.bin").unwrap();
    println!("Successfully loaded proof: {:?}", proof.bytes());
    println!("Public values: {:?}", proof.public_values.to_vec());

    client.verify(&proof, &vk).expect("failed to verify proof");
    println!("Verifed Proof");

    // Setup the default contract client to interact with on-chain verifier
    let contract_client = ContractClient::default();

    // Construct the on-chain call and relay the proof to the contract.
    let call_data = ConsensusProofVerifier::verifyConsensusProofCall {
        proof: proof.bytes().into(),
        publicValues: proof.public_values.to_vec().into(),
    }
    .abi_encode();
    contract_client.send(call_data).await?;

    Ok(())
}
