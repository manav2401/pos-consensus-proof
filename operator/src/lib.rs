use sp1_sdk::{ProverClient, SP1ProofWithPublicValues, SP1ProvingKey, SP1Stdin, SP1VerifyingKey};

pub mod contract;
pub mod utils;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const CONSENSUS_PROOF_ELF: &[u8] =
    include_bytes!("../../program/elf/riscv32im-succinct-zkvm-elf");

pub struct ConsensusProver {
    pub prover_client: ProverClient,
    pub pkey: SP1ProvingKey,
    pub vkey: SP1VerifyingKey,
}

impl Default for ConsensusProver {
    fn default() -> Self {
        Self::new()
    }
}

impl ConsensusProver {
    pub fn new() -> Self {
        println!("Initializing SP1 ProverClient...");
        let prover_client = ProverClient::new();
        let (pkey, vkey) = prover_client.setup(CONSENSUS_PROOF_ELF);
        println!("SP1 ProverClient initialized");
        Self {
            prover_client,
            pkey,
            vkey,
        }
    }

    /// Generate a consensus proof suggesting that a state root associated to a bor block has gone
    /// through 2/3+1 consensus in heimdall through the milestone message. Returns an
    /// SP1Groth16Proof.
    pub fn generate_consensus_proof(&self) -> SP1ProofWithPublicValues {
        // // Encode the light blocks to be input into our program.
        // let encoded_1 = serde_cbor::to_vec(&trusted_light_block).unwrap();
        // let encoded_2 = serde_cbor::to_vec(&target_light_block).unwrap();

        // // Write the encoded light blocks to stdin.
        let stdin = SP1Stdin::new();
        // stdin.write_vec(encoded_1);
        // stdin.write_vec(encoded_2);

        // Generate the proof. Depending on SP1_PROVER env variable, this may be a mock, local or network proof.
        let proof = self
            .prover_client
            .prove(&self.pkey, stdin)
            .plonk()
            .run()
            .expect("Failed to execute.");

        // Return the proof.
        proof
    }
}
