use common::PoSConsensusInput;
use sp1_sdk::{
    include_elf, EnvProver, HashableKey, ProverClient, SP1ProofWithPublicValues, SP1ProvingKey,
    SP1Stdin, SP1VerifyingKey,
};
use std::time::Instant;

pub mod contract;
pub mod types;
pub mod utils;

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `operator` directory. It picks
/// up the name from an environment variable with prefix `SP1_ELF_`.
pub const CONSENSUS_PROOF_ELF: &[u8] = include_elf!("pos-consensus-proof");
pub struct ConsensusProver {
    pub prover_client: EnvProver,
    pub pkey: SP1ProvingKey,
    pub vkey: SP1VerifyingKey,
}

impl Default for ConsensusProver {
    fn default() -> Self {
        Self::new()
    }
}

impl ConsensusProver {
    pub fn new() -> Self {
        tracing::info!("Initializing SP1 ProverClient...");
        sp1_sdk::utils::setup_logger();
        let prover_client = ProverClient::from_env();
        let (pkey, vkey) = prover_client.setup(CONSENSUS_PROOF_ELF);
        tracing::info!("SP1 ProverClient initialized!");
        tracing::info!("VKey: {:?}", vkey.bytes32());
        Self {
            prover_client,
            pkey,
            vkey,
        }
    }

    /// Generate a PLONK proof of consensus which states that a state root associated with a
    /// bor block majority by stake (>2/3 of total stake) votes in heimdall consensus through
    /// the milestone message. It returns the generated PLONK proof.
    pub fn generate_consensus_proof_plonk(
        &self,
        input: PoSConsensusInput,
    ) -> SP1ProofWithPublicValues {
        let now = Instant::now();
        tracing::info!("Starting to generate PLONK proof...");

        let mut stdin = SP1Stdin::new();
        stdin.write(&input);

        // Generate the proof. Depending on SP1_PROVER env variable, this may be a mock,
        // local or network proof.
        let proof = self
            .prover_client
            .prove(&self.pkey, &stdin)
            .plonk()
            .run()
            .expect("Failed to generate PLONK proof.");

        let elapsed = now.elapsed();
        tracing::info!("Done generating PLONK proof in {:.2?}", elapsed);

        // Return the proof.
        proof
    }

    /// Generate a Compressed proof of consensus which states that a state root associated with a
    /// bor block majority by stake (>2/3 of total stake) votes in heimdall consensus through
    /// the milestone message. It returns the generated compressed proof.
    pub fn generate_consensus_proof_compressed(
        &self,
        input: PoSConsensusInput,
    ) -> SP1ProofWithPublicValues {
        let now = Instant::now();
        tracing::info!("Starting to generate compressed proof...");

        let mut stdin = SP1Stdin::new();
        stdin.write(&input);

        // Generate the proof. Depending on SP1_PROVER env variable, this may be a mock,
        // local or network proof.
        let proof = self
            .prover_client
            .prove(&self.pkey, &stdin)
            .compressed()
            .run()
            .expect("Failed to generate compressed proof.");

        let elapsed = now.elapsed();
        tracing::info!("Done generating compressed proof in {:.2?}", elapsed);

        // Return the proof.
        proof
    }

    pub fn verify_consensus_proof(&self, proof: &SP1ProofWithPublicValues) {
        let now = Instant::now();
        tracing::info!("Starting to verify proof...");
        self.prover_client
            .verify(proof, &self.vkey)
            .expect("Failed to verify proof.");
        let elapsed = now.elapsed();
        tracing::info!("Done verifying proof in {:.2?}", elapsed);
    }

    pub fn execute(&self, input: PoSConsensusInput) {
        let now = Instant::now();
        tracing::info!("Starting to execute program...");

        let mut stdin = SP1Stdin::new();
        stdin.write(&input);

        let (_, report) = self
            .prover_client
            .execute(&self.pkey.elf, &stdin)
            .run()
            .unwrap();

        let elapsed = now.elapsed();
        tracing::info!(
            "Done executing program in {} cycles and {:.2?} time",
            report.total_instruction_count(),
            elapsed
        );
    }
}
